#!/usr/bin/env python3

import argparse
import json
import os
import shutil
import sys


class color:
    CLEAR = '0'
    BOLD = '1'
    UNDER = '4'
    BLINK = '5'
    REVERSE = '7'
    CONCEALED = '8'

    FG = '3'
    BG = '4'

    BLACK = '0'
    RED = '1'
    GREEN = '2'
    YELLOW = '3'
    BLUE = '4'
    MAGENTA = '5'
    CYAN = '6'
    WHITE = '7'

    @classmethod
    def ize(cls, text, attrs='', reset='CLEAR'):
        attrs = attrs.split(' ')
        if attrs:
            prefix = '\u001B['
            for attr in attrs:
                if attr:
                    endval = ';'
                    attr = attr.upper()
                    if attr in ('FG', 'BG'):
                        endval = ''
                    attr = getattr(cls, attr)
                    prefix += attr + endval
            prefix = prefix[:-1] + 'm'

            text = prefix + text

        if reset is not None and reset is not False:
            text += cls.ize('', 'CLEAR', reset=False)
            if reset.upper() != 'CLEAR':
                text += cls.ize('', reset, reset=False)

        return text


FMT_NAME = 'bold fg green'
FMT_PATH = 'bold fg red'
FMT_DIR = 'bold fg blue'
FMT_CAT = 'bold fg yellow'
FMT_DESC = ''
FMT_HIGHLIGHT = 'under'
FMT_ALERT = 'bold bg red'

PROJECTS_DIR = os.path.join(os.path.expanduser('~'), 'Projects')
GLOBAL_CFG_PATH = os.path.join(PROJECTS_DIR, '.cfg.json')


def selective_format(text, query, reset='CLEAR',
                     fn=color.ize, fmt=FMT_HIGHLIGHT):
    i = text.lower().find(query.lower())
    while i > -1:
        j = i + len(query)
        fmted = fn(text[i:j], fmt, reset=reset)
        text = text[:i] + fmted + text[j:]
        i = text.lower().find(query.lower(), i + len(fmted))

    return text


def print_info(name, info, show_path=False, query=None,
               show_indexed_alert=False, colors=None, wf=sys.stdout):
    if colors is None:
        colors = wf.isatty()
    if colors:
        fmt = color.ize
    else:
        def fmt(text, attrs='', reset=True):
            return text

    if query == '':
        # We don't need to do any formatting
        query = None

    if 'full_name' in info:
        full_name = info['full_name']
        if query is not None:
            full_name = selective_format(full_name, query, FMT_NAME, fmt)
            name = selective_format(name, query, FMT_DIR, fmt)

        wf.write(fmt(full_name, FMT_NAME))
        wf.write(' (')
        wf.write(fmt(name, FMT_DIR))
        wf.write(')')
    else:
        if query is not None:
            name = selective_format(name, query, FMT_NAME, fmt)
        wf.write(fmt(name, FMT_NAME))
    if show_indexed_alert:
        wf.write(' [')
        wf.write(fmt('not indexed', FMT_ALERT))
        wf.write(']')

    if show_path:
        wf.write('\n ')
        wf.write(fmt(info['path'], FMT_PATH))

    if 'categories' in info:
        wf.write('\n ')
        categories = ', '.join(info['categories'])
        if query is not None:
            categories = selective_format(categories, query, FMT_CAT, fmt)
        wf.write(fmt(categories, FMT_CAT))

    if 'description' in info:
        wf.write('\n ')
        desc = info['description']
        if query is not None:
            desc = selective_format(desc, query, FMT_DESC, fmt)
        wf.write(fmt(desc, FMT_DESC))

    wf.write('\n\n')


class Actions:
    def list(self, args):
        dirs = [entry for entry in os.listdir() if os.path.isdir(entry)]
        for d in dirs:
            if os.getcwd() == PROJECTS_DIR:
                if d in self['projects']:
                    info = self['projects'][d]
                else:
                    info = {}
            else:
                infopath = os.path.join(d, '.__info__.json')
                if os.path.isfile(infopath):
                    with open(infopath, 'r') as rf:
                        info = json.load(rf)
                else:
                    info = {}
            print_info(d, info)

    def find(self, args):
        items = list(self._cfg['projects'].items())
        items.sort(key=lambda it: it[0].lower())
        for name, info in items:
            # Check if query is in any of `name`, `'full_name'`, `'categories'`
            # or `'description'`
            found = (
                # If query is empty, everything should pass
                (args.query == '') or
                # Check `name`
                (args.query in name) or
                # Check `'full_name'`
                ('full_name' in info and
                    args.query in info['full_name']) or
                # Check `'categories'`
                ('categories' in info and
                    args.query in ', '.join(info['categories'])) or
                # Check `'description'`
                ('description' in info and
                    args.query in info['description'])
            )
            if found:
                print_info(name, info, True, args.query)

    def new(self, args):
        if args.name in self['projects']:
            self.p_new.error('The name "{}" is already taken'
                             .format(args.name))

        path = args.name
        if args.here:
            path = os.path.relpath(path, os.path.expanduser('~'))
            path = os.path.join('~', path)
        else:
            path = os.path.join('~', 'Projects', path)

        if os.path.exists(
                os.path.expanduser(os.path.join(path, '.__info__.json'))):
            self.p_new.error('"{}" already has an entry for ".__info__.json" '
                             '(it is probably already a project - maybe you '
                             'wanted `{} import`?)'
                             .format(path, sys.argv[0]))

        if args.generator is not None:
            self.p_new.error('Generators are not yet implemented')

        cfg = {
            'path': path
        }

        if args.full_name is not None:
            cfg['full_name'] = args.full_name

        if args.categories is not None:
            cfg['categories'] = args.categories

        if args.description is not None:
            if args.description == '--':
                desc = sys.stdin.read()
            else:
                desc = args.description
            cfg['description'] = args.description

        os.makedirs(os.path.expanduser(path), exist_ok=True)

        self['projects'][args.name] = cfg
        self._save_cfg()

        if args.here:
            with open(os.path.join(os.path.expanduser(path), '.__info__.json'),
                      'w') as wf:
                json.dump(cfg, wf)

    def remove(self, args):
        if args.name not in self['projects']:
            self.p_remove.error('The project "{}" is not indexed'
                                .format(args.name))

        path = self['projects'][args.name]['path']
        del self['projects'][args.name]
        self._save_cfg()

        if args.remove_directory:
            shutil.rmtree(os.path.expanduser(path))

    def import_(self, args):
        if args.name in self['projects']:
            self.p_import.error('A project by the name "{}" already exists'
                                .format(args.name))

        if not os.path.isfile('.__info__.json'):
            self.p_import.error('This directory does not contain a recognized '
                                'project')

        with open('.__info__.json', 'r') as rf:
            cfg = json.load(rf)
        cfg['path'] = os.path.join(
            '~', os.path.relpath(os.getcwd(), os.path.expanduser('~'))
        )
        if cfg['path'].startswith(os.path.join('~', '..', '')):
            path = os.path.expanduser(cfg['path'])
            cfg['path'] = os.path.abspath(path)

        self['projects'][args.name] = cfg
        self._save_cfg()

    def info(self, args):
        indexed = True
        if args.name is None:
            args.name, info = self._find_by_path(os.getcwd())
            if args.name is None:
                indexed = False
                args.name = os.path.split(os.getcwd())[-1]
                if os.path.isfile('.__info__.json'):
                    with open('.__info__.json', 'r') as rf:
                        info = json.load(rf)
                else:
                    self.p_info.error('This directory does not contain a '
                                      'recognized project')
        elif args.name in self['projects']:
            info = dict(self['projects'][args.name])
        else:
            self.p_info.error('A project by the name "{}" could not be found.'
                              .format(args.name))

        if args.absolute_path:
            info['path'] = os.path.abspath(os.path.expanduser(info['path']))

        if args.full_name:
            if 'full_name' in info:
                print(info['full_name'])
        elif args.categories:
            if 'categories' in info:
                print(','.join(info['categories']))
        elif args.description:
            if 'description' in info:
                print(info['description'])
        elif args.path:
            if 'path' in info:
                print(info['path'])
        else:
            print_info(
                args.name, info,
                show_path=True, show_indexed_alert=not indexed
            )

    def __init__(self, parser=None):
        # Ensure config exists
        os.makedirs(PROJECTS_DIR, exist_ok=True)
        if not os.path.isfile(GLOBAL_CFG_PATH):
            with open(GLOBAL_CFG_PATH, 'w') as wf:
                json.dump({
                    'projects': {}
                }, wf)

        self._load_cfg()

        if parser is None:
            parser = argparse.ArgumentParser(
                description='Find and manage projects'
            )
        self._parser = parser
        subparsers = parser.add_subparsers()

        #### Subcommand: `new` (`n`)
        self.p_new = subparsers.add_parser('new',
                                           aliases=['n'],
                                           help='Create a new project')
        self.p_new.add_argument('name',
                                help='The typeable project name')
        self.p_new.add_argument('--generator', '-g',
                                nargs='+',
                                default=None,
                                help='A generator to use')
        self.p_new.add_argument('--categories', '-c',
                                nargs='+',
                                default=None,
                                help='Categories to add')
        self.p_new.add_argument('--full-name', '-n',
                                default=None,
                                help='Use a different human-readable name')
        self.p_new.add_argument('--description', '-d',
                                default=None,
                                help='Use a description.\n'
                                     "If the description is '--', "
                                     "reads from stdin.")
        self.p_new.add_argument('--here',
                                action='store_true',
                                help='Create the project directory here')
        self.p_new.set_defaults(func=self.new)

        #### Subcommand: `remove` (`rm`, `delete`, `del`)
        self.p_remove = subparsers.add_parser('remove',
                                              aliases=['rm', 'delete', 'del'],
                                              help='De-registers the named '
                                              'project.')
        self.p_remove.add_argument('name',
                                   help='The project to delete. Must be an '
                                   'exact match.')
        self.p_remove.add_argument('--remove-directory', '-d',
                                   action='store_true',
                                   help='Removes entire project. from the '
                                   'file system.')
        self.p_remove.set_defaults(func=self.remove)

        #### Subcommand: `list` (`ls`, `l`)
        self.p_ls = subparsers.add_parser('list',
                                          aliases=['ls', 'l'],
                                          help='Lists the projects in the '
                                          'current directory.')
        self.p_ls.set_defaults(func=self.list)

        #### Subcommand: `find` (`f`)
        self.p_find = subparsers.add_parser('find',
                                            aliases=['f'],
                                            help='Find among all projects')
        self.p_find.add_argument('query',
                                 nargs='?', default='',
                                 help='The text to search for')
        self.p_find.set_defaults(func=self.find)

        #### Subcommand: `import`
        self.p_import = subparsers.add_parser('import',
                                              help='Imports an existing '
                                              'project in the current '
                                              'directory into the index')
        self.p_import.add_argument('name',
                                   nargs='?',
                                   default=os.path.split(os.getcwd())[-1],
                                   help='The name to register as. If omitted, '
                                   'uses the directory name.')
        self.p_import.set_defaults(func=self.import_)

        #### Subcommand: `info`
        self.p_info = subparsers.add_parser('info',
                                            help='Displays info for a project')
        self.p_info.add_argument('name',
                                 nargs='?', default=None,
                                 help='The name of the project to view info '
                                 'on. If omitted, it tries to take the '
                                 'project in the current directory.')
        self.p_info.add_argument('--full-name', '-n',
                                 action='store_true',
                                 help='Only display the full name')
        self.p_info.add_argument('--categories', '-c',
                                 action='store_true',
                                 help='Only display the categories')
        self.p_info.add_argument('--description', '-d',
                                 action='store_true',
                                 help='Only display the description')
        self.p_info.add_argument('--path', '-p',
                                 action='store_true',
                                 help='Only display the path')
        self.p_info.add_argument('--absolute-path',
                                 action='store_true',
                                 help='Display an absolute path, even if it '
                                 'is under the user directory.')
        self.p_info.set_defaults(func=self.info)

    def _find_by_attr(self, attr, value):
        for name, info in self['projects'].items():
            if (
                attr in info and (
                    info[attr] == value or
                    (hasattr(info[attr], '__contains__') and
                        value in info[attr])
                )
            ):
                yield name, info

    def _find_by_path(self, path):
        path = os.path.abspath(os.path.expanduser(path))
        for name, info in self['projects'].items():
            if os.path.abspath(os.path.expanduser(info['path'])) == path:
                return name, info
        return None, None

    def _load_cfg(self):
        with open(GLOBAL_CFG_PATH, 'r') as rf:
            self._cfg = json.load(rf)

    def _save_cfg(self):
        with open(GLOBAL_CFG_PATH, 'w') as wf:
            json.dump(self._cfg, wf)

    def __getitem__(self, k):
        return self._cfg[k]

    def __setitem__(self, k, v):
        self._cfg[k] = v

    def __delitem__(self, k):
        del self._cfg[k]

    def __contains__(self, k):
        return k in self._cfg

    def run(self, args=None):
        args = self._parser.parse_args(args)
        args.func(args)


actions = Actions()

if __name__ == '__main__':
    actions.run()
